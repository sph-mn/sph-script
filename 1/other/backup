#!/usr/bin/guile
!#

(import (sph filesystem) (sph hashtable)
  (sph io) (sph list)
  (sph number) (sph other)
  (sph process) (sph string)
  (sph vector) (sph)
  (guile) (sph process)
  (sph process create) (sph cli) (sph time string) (only (ice-9 ftw) scandir) (rnrs sorting))

(define program-description
  (string-join
    (list "a backup archive creator"
      "sources are config file names and can be multiple names separated by a dot, for example \"mail.system.documents\""
      "destinations are existing directory paths")
    "\n  "))

(define program-dependencies (q ("pack")))
(define max-bits-for-compression (expt 2 31))
(define path-config-home (string-append (getenv "HOME") "/.config/backup/"))
(define path-config-etc (string-append "/etc/backup/"))

(define (get-path-config)
  (if (file-exists? path-config-home) path-config-home
    (if (file-exists? path-config-etc) path-config-etc
      (raise (pair (q no-accessible-configuration-path) (list path-config-home path-config-etc))))))

(define default-destination (getcwd))
(define (display-process-arguments . a) (display-line (string-join a " ")))

(define (create-result-backup-tarsnap sources dry-run)
  (every
    (l (source)
      (let (path-filelist (tmpnam)) (call-with-output-file path-filelist (tail source))
        ( (if dry-run display-process-arguments execute) "tarsnap" "-cf"
          (source-names->destination-file-name (first source)) "-T" path-filelist)
        (delete-file path-filelist)))
    sources))

(define (source-names->destination-file-name a)
  (string-append (if (string? a) a (string-join a "-")) "." (utc-current-ymd-s)))

(define (create-full-destination-path source-names destination-path use-default-destination)
  (if destination-path
    (if (string-suffix? "/" destination-path)
      (string-append destination-path (source-names->destination-file-name source-names))
      destination-path)
    (string-append (if use-default-destination default-destination "")
      (source-names->destination-file-name source-names))))

(define (source->file-size-sum source)
  "(string:name . procedure:nullary:writes-paths-to-standard-output) -> integer"
  (call-with-pipes 2
    (l (in-a out-a in-b out-b)
      (let (pid (process-create "file-size-sum" (list) in-a out-b #:search-path? #t))
        (close-port in-a) (close-port out-b)
        ((tail source) out-a) (close-port out-a)
        (begin-first (string->number (string-trim-right (port->string in-b))) (close-port in-b)
          (process-finish pid))))))

(define (pack-process-arguments source-name path dry-run encrypt size)
  (pairs "pack" "--read-paths=-"
    (compact
      (list
        (and path (string-append "--target=" (create-full-destination-path source-name path #t)))
        (and (<= size max-bits-for-compression) "--compression") (and dry-run "--dry-run")
        (and encrypt "--encryption")))))

(define create-result-backup-files
  (let
    (validate-destination-paths
      (l (a)
        (let
          (non-directories (filter (l (a) (catch #t (nullary (not (directory? a))) (const #t))) a))
          (if (null? non-directories) #t
            (raise (pair (q non-directory-destination-paths) non-directories))))))
    (l (sources destinations encrypt dry-run)
      (let
        ( (destination-paths
            (map ensure-trailing-slash
              (if destinations (map realpath* destinations) (list default-destination)))))
        (validate-destination-paths destination-paths)
        (every
          (l (source)
            (let (size (source->file-size-sum source))
              (every
                (l (destination-path)
                  (if dry-run
                    (apply display-process-arguments
                      (pack-process-arguments (first source) destination-path dry-run encrypt size))
                    (call-with-pipe
                      (l (in out)
                        (and-let*
                          ( (a
                              (pack-process-arguments (first source) destination-path
                                dry-run encrypt size))
                            (pid (process-create (first a) (tail a) in #:search-path? #t)))
                          (close-port in) ((tail source) out)
                          (close-port out) (process-finish-success? pid))))))
                destination-paths)))
          sources)))))

(define (name->source-path a path-config) "string -> string" (string-append path-config a))

(define (get-source-names path-config) "-> (string ...)/false"
  (false-if-exception
    (filter
      (l (e)
        (and (not (or (string-equal? e ".") (string-equal? e "..")))
          (let (stat-info (stat (string-append path-config e)))
            (and (eqv? (q regular) (stat:type stat-info))
              (not (= 0 (logand 73 (stat:perms stat-info))))))))
      (scandir path-config))))

(define (create-result-list-configs path-config)
  (display-line (string-join (list-sort string<? (get-source-names path-config)) " ")) #f)

(define (create-result-show-config source-names path-config)
  (each (l (a) (display (file->string (name->source-path a path-config)))) source-names) #f)

(define (create-result-list-files source-names path-config)
  (each
    (l (a)
      (call-with-working-directory path-config
        (nullary (execute (name->source-path a path-config)))))
    source-names)
  #f)

(define (source-names->sources sources combine? path-config)
  "(string ...) boolean string -> ((string/list:name . procedure:generator) ...)
   creates generator procedures that list input files"
  (if combine?
    (list
      (pair sources
        (l (out)
          (call-with-working-directory path-config
            (nullary (each (l (a) (execute->port out (name->source-path a path-config))) sources)))
          (force-output))))
    (map
      (l (a)
        (pair a
          (l (out)
            (call-with-working-directory path-config
              (nullary (execute->port out (name->source-path a path-config))))
            (force-output))))
      sources)))

(define create-result-backup
  (let
    (validate-source-names
      (l (a path-config)
        (let (missing-source-names (complement a (get-source-names path-config)))
          (if (null? missing-source-names) #t
            (raise (pair (q missing-source-names) missing-source-names))))))
    (l (combine destinations dry-run encrypt source-names tarsnap path-config)
      (validate-source-names source-names path-config)
      (let (sources (source-names->sources source-names combine path-config))
        (if tarsnap (create-result-backup-tarsnap sources dry-run)
          (create-result-backup-files sources destinations encrypt dry-run))))))

(define*
  (backup #:key combine destinations dry-run encrypt list-configs list-files show-config sources
    tarsnap)
  (let (path-config (get-path-config))
    (cond
      (list-files (create-result-list-files sources path-config))
      (list-configs (create-result-list-configs path-config))
      (show-config (create-result-show-config sources path-config))
      (else (create-result-backup combine destinations dry-run encrypt sources tarsnap path-config)))))

(define backup-cli
  (let
    ( (cli-sources (l (a) (string-split a #\.)))
      (command-line-interface
        (cli-create #:description program-description
          #:options
          (list-q (dry-run) (tarsnap #:names #\t)
            (list-configs #:names #\l #:description "lists the recognised backup configurations")
            (list-files #:description "list files that would be included in the backup")
            (show-config #:description "display contents a configuration file")
            (combine #:description
              "combine dot separated configuration names and create one backup file")
            (encrypt #:names #\e) ((sources destinations ...) #:required? #f #:value-required? #t)))))
    (nullary
      (let
        (keyword-arguments
          (append-map
            (l (a)
              (let ((key (first a)) (value (tail a)))
                (list (symbol->keyword key)
                  (case key
                    ((sources) (cli-sources value))
                    (else value)))))
            (command-line-interface)))
        (apply backup keyword-arguments)))))

(backup-cli)
