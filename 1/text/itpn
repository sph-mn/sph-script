#!/usr/bin/guile
!#

(import (ice-9 ftw) (sph common)
  (sph lang itpn) (sph two) (sph lang indent-syntax) (sph replacement-table))

(define program-description "indent packet notation filter and transformer")
;todo
;  partition
;  output-to-source

(define command-line-interface
  (cli-create #:help program-description
    #:options
    (ql ((file-paths ...)) (search #:names #\s #:value-required? #t)
      (search-suffix #:value-required? #t) (search-all #:names #\a #:value-required? #t)
      (sort-facets)
      (replace-facet #:value-required? #t
        #:description "value format: \"facet[.facet] facet[.facet]\"")
      (replace-facets-from-file #:value-required? #t
        #:description
        "takes a path to a file that contains lines in the format \"facet replacement ...\"")
      (include-file-name-facets)
      (partition #:description
        "split into matches and non-matches. output-file-1 receives matches, output-file-2 non-matches, and if any of those is not specified output is written to standard output")
      (output-to-source #:description
        "overwrite source files for output that has no specified output-file and would be written to standard-output")
      (output-file-1 #:value-required? #t #:description "path for a file to write matches to")
      (output-file-2 #:value-required? #t #:description "path for a file to write non-matches to")
      (format #:value-required? #t
        #:description "prefix/suffix/file. comma-separated list of names of parts to display")
      (exclude #:names #\e) (syntax-check #:names #\c) (list-unique-facets) (sort-packets))))

(define (cli-parse-replace-facet a) "string:\"facet[.facet ...] facet[.facet ...]\" -> list"
  (apply (l (facet replacements) (pair facet (string-split replacements #\.)))
    (string-split a #\space)))

(define (itpn-packet-map-facet-list proc packet)
  (map-first (l (a) (string-join (proc (string-split a #\space)) " ")) packet))

(define (itpn-packet-map-facets proc packet)
  (itpn-packet-map-facet-list (l (a) (map proc a)) packet))

(define (create-parsed-itpn-processors arguments) "alist -> (procedure ...)"
  (alist-bind arguments
    (search search-all search-suffix
      sort-facets exclude
      sort-packets include-file-name-facets replace-facet replace-facets-from-file partition extract)
    (compact
      (list
        (and include-file-name-facets
          (l (a path)
            (if (string? path)
              (let
                (file-name-prefix (string-join (string-split (basename path) #\.) " " (q suffix)))
                (map (l (a) (pair (string-append file-name-prefix (first a)) (tail a))) a))
              a)))
        (and replace-facet
          (apply
            (l (old . new)
              (l (a path)
                (map
                  (l (packet)
                    (itpn-packet-map-facet-list
                      (l (a)
                        (delete-duplicates
                          (flatten (map (l (a) (if (string-equal? old a) new a)) a))))
                      packet))
                  a)))
            (cli-parse-replace-facet replace-facet)))
        (and (string? replace-facets-from-file)
          (let (table (replacement-table-from-file replace-facets-from-file))
            (l (a path)
              (map
                (l (packet)
                  (itpn-packet-map-facet-list
                    (l (a) (delete-duplicates (flatten (list-replace-from-hashtable a table))))
                    packet))
                a))))
        (and sort-facets (l (a path) (itfpn-facets-sort a string<?)))
        ;an optimisation could be possible here by evaluating the search before other processors. questions are
        ;if the search should run after replace and what happens when the list is split into matches and non-matches
        (and (or search search-suffix search-all partition)
          (let
            ( (patterns-prefix (or (and search (string-split search #\,)) (list)))
              (patterns-suffix (or (and search-suffix (string-split search-suffix #\,)) (list)))
              (patterns-anywhere (or (and search-all (string-split search-all #\,)) (list))))
            (l (parsed-itpn path)
              ( (if exclude (if partition reverse tail) (if partition identity first))
                (itpn-filter-all-patterns-all-parts parsed-itpn patterns-prefix
                  patterns-suffix patterns-anywhere)))))))))

(define (get-all-itpn-from-standard-input)
  (string-if-exception (read-space-indent-tree->prefix-tree (current-input-port))))

(define (get-all-itpn-from-file-path path)
  (string-if-exception
    (call-with-input-file path (l (port) (read-space-indent-tree->prefix-tree port)))))

(define (itpn-contains-empty-line? parsed-itpn) (contains? parsed-itpn ""))
(define (itpn-empty-line-first-index parsed-itpn) (list-index-value parsed-itpn ""))

(define (create-error-data file-name packet-number other)
  (compact
    (list "empty-line" (and file-name (string-append "file: " (string-quote file-name)))
      (and packet-number (string-append "packet: " (number->string packet-number))) (and other))))

(define (check-for-parse-errors& parsed-itpn path c)
  (if (string? parsed-itpn)
    (error-create (q syntax-invalid) (create-error-data path #f parsed-itpn))
    (let (empty-line-index (itpn-empty-line-first-index parsed-itpn))
      (if empty-line-index
        (error-create (q syntax-invalid) (create-error-data path empty-line-index #f)) (c)))))

(define (format-error-data a) (if (list? a) a (any->string a)))

(define (display-error-and-exit error)
  (display-line
    (prefix-tree->indent-tree-string
      (list (any->string (error-name error)) (format-error-data (error-data error))))
    (current-error-port))
  (exit 1))

(define (file-system-fold-error name stat errno result)
  (format (current-error-port) "warning: ~a: ~a~%" name (strerror errno)))

(define (file-system-fold-identity name stat result) result)

(define (file-system-fold* enter? leaf down up skip error init paths)
  "procedure procedure procedure procedure procedure procedure any (string ...) -> any
  maps paths with calls to file-system-fold. stops on error"
  (first
    (fold-multiple-with-continue
      (l (path continue r)
        (let (r-new (file-system-fold enter? leaf down up skip error r path))
          (if (error? r-new) (list r-new) (continue r-new))))
      paths init)))

(define (input-handler-proc arguments)
  (alist-bind arguments (list-unique-facets partition syntax-check)
    (let*
      ( (parsed-itpn-processors (create-parsed-itpn-processors arguments))
        (apply-processors
          (l (parsed-itpn path)
            (fold (l (processor r) (processor r path)) parsed-itpn parsed-itpn-processors)))
        (with-type-and-create-result
          (l (c)
            (cond (syntax-check (c (q syntax-check) (l (parsed-itpn path) (list #t))))
              (list-unique-facets
                (c (q unique-facets) (l (parsed-itpn path) (itfpn-facets parsed-itpn))))
              (partition (c (q partition) apply-processors))
              (else (c (q parsed-itpn) apply-processors))))))
      (l (paths process-one)
        "(string ...) procedure:{parsed-itpn -> any} -> any
        manages and accesses input resources and processing"
        (with-type-and-create-result
          (l (type create-result)
            (if paths
              (let (inaccessible-path (find (negate file-exists?) paths))
                (if inaccessible-path (error-create (q inaccessible-path) inaccessible-path)
                  (error-pass-if-not
                    (file-system-fold* (l (path stat r) (not (error? r)))
                      (l (path stat r)
                        (if (error? r) r
                          (let
                            (r-one
                              (process-one (get-all-itpn-from-file-path path) path create-result))
                            (if (error? r-one) r-one (pair r-one r)))))
                      file-system-fold-identity file-system-fold-identity
                      file-system-fold-identity file-system-fold-error (list) paths)
                    (l (r) (pair type r)))))
              (list type
                (process-one (get-all-itpn-from-standard-input) "standard-input" create-result)))))))))

(define (arguments->formats& arguments c)
  "list {show-file? show-prefix? show-suffix? -> any} -> any"
  (let (format (alist-q-ref arguments format))
    (if format
      (let (format (string-split format #\,))
        (apply c (map (l (a) (contains? format a)) (list "file" "prefix" "suffix"))))
      (c #f #t #t))))

(define (process-one-proc arguments)
  "alist -> error/any
  creates a result for one list of parsed-itpn packets (for example read from the contents of a file or standard-input)"
  (l (parsed-itpn path create-result)
    "list string/symbol -> (symbol:mode-prefix string/symbol:path result-data ...)"
    (check-for-parse-errors& parsed-itpn path (thunk (pair path (create-result parsed-itpn path))))))

(define (result-map-data proc a) "procedure list -> list"
  (apply (l (type path . data) (pairs type path (proc data))) a))

(define (process-after-proc arguments)
  (let
    ( (list-unique-facets? (alist-q-ref arguments list-unique-facets))
      (sort-packets? (alist-q-ref arguments sort-packets)))
    (l (result) "list -> list"
      (let (type (first result))
        (cond
          ( (eqv? (q unique-facets) type)
            (result-map-data (l (a) (list-sort string<? (delete-duplicates a))) result))
          (sort-packets? (result-map-data (l (a) (itpn-packets-sort a string<?)) result))
          (else result))))))

(define (display-parsed-itpn-one port path a show-file? show-prefix? show-suffix?)
  (let*
    ( (indent-level 0)
      (indent-level
        (if (and show-file? (not (null? a)) (string? path))
          (begin (display-line path port) (+ 1 indent-level)) indent-level))
      (indent-1 (create-indent indent-level)) (indent-2 (create-indent (+ 1 indent-level))))
    (each
      (l (packet)
        (let
          (indent-level
            (if show-prefix?
              (begin (display-line (string-append indent-1 (first packet)) port) (+ 1 indent-level))
              indent-level))
          (if show-suffix?
            (display-line (prefix-tree->indent-tree-string (tail packet) indent-level) port))))
      a)))

(define (output-handler-proc arguments) "list list ->"
  (alist-bind arguments (output-file-1 output-file-2 output-to-source)
    (let*
      ( (call-with-output-port
          (l (file indirect? c)
            (if indirect?
              (if file (rw-with-temporary-file-port->file c file) (c (current-output-port)))
              (if file (call-with-output-file file c) (c (current-output-port))))))
        (call-with-output-ports
          (l (data proc)
            (if output-to-source
              (call-with-output-port (or output-file-1 output-file-2) #f
                (l (port-other)
                  (map-apply
                    (l (path . a)
                      (call-with-output-port path #t
                        (l (port-source)
                          ;output-file-1 is mapped to take matches, output-file-2 takes non-matches
                          (if output-file-1 (apply proc path port-other port-source a)
                            (apply proc path port-source port-other a)))))
                    data)))
              (call-with-output-port output-file-1 #f
                (l (port-1)
                  (call-with-output-port output-file-2 #f
                    (l (port-2) (map-apply (l a (apply proc port-1 port-2 a)) data)))))))))
      (arguments->formats& arguments
        (l (show-file? show-prefix? show-suffix?)
          (l (result)
            (apply
              (l (type . data)
                (case type
                  ( (parsed-itpn)
                    (if output-to-source
                      (map-apply
                        (l (path . data)
                          (call-with-output-port path #t
                            (l (port)
                              (display-parsed-itpn-one port path
                                data show-file? show-prefix? show-suffix?))))
                        data)
                      (call-with-output-port output-file-1 #f
                        (l (port)
                          (map-apply
                            (l (path . data)
                              (display-parsed-itpn-one port path
                                data show-file? show-prefix? show-suffix?))
                            data)))))
                  ( (partition)
                    (call-with-output-ports data
                      (l (port-matches port-non-matches path packets-matching packets-not-matching)
                        (display-parsed-itpn-one port-matches path
                          packets-matching show-file? show-prefix? show-suffix?)
                        (display-parsed-itpn-one port-non-matches path
                          packets-not-matching show-file? show-prefix? show-suffix?))))
                  (else (display-line result))))
              result)))))))

(define (result-handler arguments a process-after output-handler) "list list -> [list]"
  (if (error? a) a
    (if (null? a) (exit 0)
      (case (first a) ((syntax-check) (exit (if (every identity (tail (tail a))) 0 1)))
        ((parsed-itpn partition) (error-pass-if-not (process-after a) output-handler))))))

(define (itpn-filter-cli)
  (let* ((arguments (command-line-interface)))
    (error-pass-if
      (result-handler arguments
        ( (input-handler-proc arguments) (alist-q-ref arguments file-paths)
          (process-one-proc arguments))
        (process-after-proc arguments) (output-handler-proc arguments))
      display-error-and-exit)))

(itpn-filter-cli)
