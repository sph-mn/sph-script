#!/usr/bin/guile
!#

(import (ice-9 ftw) (sph common)
  (sph lang itpn) (sph two) (sph lang indent-syntax) (sph replacement-table))

(define program-description "indent packet notation filter and transformer")
;todo
;  standard-input
;  partition
;  output-file
;  extract

(define command-line-interface
  (cli-create #:help program-description
    #:options
    (ql ((file-paths ...)) (search #:names #\s #:value-required? #t)
      (search-suffix #:value-required? #t) (search-all #:names #\a #:value-required? #t)
      (sort-facets)
      (replace-facet #:value-required? #t
        #:description "value format: \"facet[.facet] facet[.facet]\"")
      (replace-facets-from-file #:value-required? #t
        #:description
        "takes a path to a file that contains lines in the format \"facet replacement ...\"")
      (include-file-name-facets)
      (partition #:description
        "split into matches and non-matches and write matches to standard output and non-matches to a file")
      (extract #:description
        "modify input files so that only non-matches remain in it and output matches")
      (output-file #:names #\o #:value-required? #t)
      (format #:value-required? #t
        #:description "prefix/suffix/file. comma-separated list of names of parts to display")
      (exclude #:names #\e) (syntax-check #:names #\c) (list-unique-facets) (sort-packets))))

(define (cli-parse-replace-facet a) "string:\"facet[.facet ...] facet[.facet ...]\" -> list"
  (apply (l (facet replacements) (pair facet (string-split replacements #\.)))
    (string-split a #\space)))

(define (itpn-packet-map-facet-list proc packet)
  (map-first (l (a) (string-join (proc (string-split a #\space)) " ")) packet))

(define (itpn-packet-map-facets proc packet)
  (itpn-packet-map-facet-list (l (a) (map proc a)) packet))

(define (create-parsed-itpn-processors arguments) "alist -> (procedure ...)"
  (alist-quoted-bind arguments
    (search search-all search-suffix
      sort-facets exclude
      sort-packets include-file-name-facets replace-facet replace-facets-from-file partition extract)
    (compact
      (list
        (and include-file-name-facets
          (l (a path)
            (if (string? path)
              (let
                (file-name-prefix (string-join (string-split (basename path) #\.) " " (q suffix)))
                (map (l (a) (pair (string-append file-name-prefix (first a)) (tail a))) a))
              a)))
        (and replace-facet
          (apply
            (l (old . new)
              (l (a path)
                (map
                  (l (packet)
                    (itpn-packet-map-facet-list
                      (l (a)
                        (delete-duplicates
                          (flatten (map (l (a) (if (string-equal? old a) new a)) a))))
                      packet))
                  a)))
            (cli-parse-replace-facet replace-facet)))
        (and (string? replace-facets-from-file)
          (let (table (replacement-table-from-file replace-facets-from-file))
            (l (a path)
              (map
                (l (packet)
                  (itpn-packet-map-facet-list
                    (l (a) (delete-duplicates (flatten (list-replace-from-hashtable a table))))
                    packet))
                a))))
        (and sort-facets (l (a path) (itfpn-facets-sort a string<?)))
        ;the filters do not run sooner because matches and non-matches are passed up and might both be used
        ;todo: make it so that it is determined, if it will be needed, and eventually search before all other processors
        (and (or search search-suffix search-all)
          (let
            ( (patterns-prefix (or (and search (string-split search #\,)) (list)))
              (patterns-suffix (or (and search-suffix (string-split search-suffix #\,)) (list)))
              (patterns-anywhere (or (and search-all (string-split search-all #\,)) (list))))
            (l (parsed-itpn path)
              ( (if exclude (if (or partition extract) reverse tail)
                  (if (or partition extract) identity first))
                (itpn-filter-all-patterns-all-parts parsed-itpn patterns-prefix
                  patterns-suffix patterns-anywhere)))))))))

(define (get-all-itpn-from-standard-input)
  (string-if-exception (read-space-indent-tree->prefix-tree (current-input-port))))

(define (get-all-itpn-from-file-path path)
  (string-if-exception
    (call-with-input-file path (l (port) (read-space-indent-tree->prefix-tree port)))))

(define (itpn-contains-empty-line? parsed-itpn) (contains? parsed-itpn ""))
(define (itpn-empty-line-first-index parsed-itpn) (list-index-value parsed-itpn ""))

(define (create-error-data file-name packet-number other)
  (compact
    (list "empty-line" (and file-name (string-append "file: " (string-quote file-name)))
      (and packet-number (string-append "packet: " (number->string packet-number))) (and other))))

(define (check-for-parse-errors& parsed-itpn path c)
  (if (string? parsed-itpn)
    (error-create (q syntax-invalid) (create-error-data path #f parsed-itpn))
    (let (empty-line-index (itpn-empty-line-first-index parsed-itpn))
      (if empty-line-index
        (error-create (q syntax-invalid) (create-error-data path empty-line-index #f)) (c)))))

(define (format-error-data a) (if (list? a) a (any->string a)))

(define (display-error-and-exit error)
  (display-line
    (prefix-tree->indent-tree-string
      (list (any->string (error-name error)) (format-error-data (error-data error))))
    (current-error-port))
  (exit 1))

(define (file-system-fold-error name stat errno result)
  (format (current-error-port) "warning: ~a: ~a~%" name (strerror errno)))

(define (file-system-fold-identity name stat result) result)

(define (file-system-fold* enter? leaf down up skip error init paths)
  "procedure procedure procedure procedure procedure procedure any (string ...) -> any
  maps paths with calls to file-system-fold. stops on error"
  (first
    (fold-multiple-with-continue
      (l (path continue r)
        (let (r-new (file-system-fold enter? leaf down up skip error r path))
          (if (error? r-new) (list r-new) (continue r-new))))
      paths init)))

(define (input-handler-proc arguments)
  (let
    ( (syntax-check? (alist-q-ref arguments syntax-check))
      (list-unique-facets? (alist-q-ref arguments list-unique-facets))
      (parsed-itpn-processors (create-parsed-itpn-processors arguments)))
    (let
      (with-type-and-create-result
        (l (c)
          (cond (syntax-check? (c (q syntax-check) (l (parsed-itpn path) (list #t))))
            (list-unique-facets?
              (c (q unique-facets) (l (parsed-itpn path) (itfpn-facets parsed-itpn))))
            (else
              (c (q parsed-itpn)
                (l (parsed-itpn path)
                  (fold (l (proc r) (proc r path)) parsed-itpn parsed-itpn-processors)))))))
      (l (paths process-one)
        "(string ...) procedure:{parsed-itpn -> any} -> any
        manages and accesses input resources and processing"
        (with-type-and-create-result
          (l (type create-result)
            (if paths
              (let (inaccessible-path (find (negate file-exists?) paths))
                (if inaccessible-path (error-create (q inaccessible-path) inaccessible-path)
                  (error-pass-if-not
                    (file-system-fold* (l (path stat r) (not (error? r)))
                      (l (path stat r)
                        (if (error? r) r
                          (let
                            (r-one
                              (process-one (get-all-itpn-from-file-path path) path create-result))
                            (if (error? r-one) r-one (pair r-one r)))))
                      file-system-fold-identity file-system-fold-identity
                      file-system-fold-identity file-system-fold-error (list) paths)
                    (l (r) (pair type r)))))
              (list type
                (process-one (get-all-itpn-from-standard-input) (q standard-input) create-result)))))))))

(define (arguments->formats& arguments c)
  "list {show-file? show-prefix? show-suffix? -> any} -> any"
  (let (format (alist-q-ref arguments format))
    (if format
      (let (format (string-split format #\,))
        (apply c (map (l (a) (contains? format a)) (list "file" "prefix" "suffix"))))
      (c #f #t #t))))

(define (process-one-proc arguments)
  "alist -> error/any
  creates a result for one list of parsed-itpn packets (for example read from the contents of a file or standard-input)"
  (l (parsed-itpn path create-result)
    "list string/symbol -> (symbol:mode-prefix string/symbol:path result-data ...)"
    (check-for-parse-errors& parsed-itpn path (thunk (pair path (create-result parsed-itpn path))))))

(define (result-map-data proc a) "procedure list -> list"
  (apply (l (type path . data) (pairs type path (proc data))) a))

(define (process-after-proc arguments)
  (let
    ( (list-unique-facets? (alist-q-ref arguments list-unique-facets))
      (sort-packets? (alist-q-ref arguments sort-packets)))
    (l (result) "list -> list"
      (let (type (first result))
        (cond
          ( (eqv? (q unique-facets) type)
            (result-map-data (l (a) (list-sort string<? (delete-duplicates a))) result))
          (sort-packets? (result-map-data (l (a) (itpn-packets-sort a string<?)) result))
          (else result))))))

(define (display-parsed-itpn-one path a show-file? show-prefix? show-suffix?)
  (let*
    ( (indent-level 0)
      (indent-level
        (if (and show-file? (not (null? a)) (string? path))
          (begin (display-line path) (+ 1 indent-level)) indent-level))
      (indent-1 (create-indent indent-level)) (indent-2 (create-indent (+ 1 indent-level))))
    (each
      (l (packet)
        (let
          (indent-level
            (if show-prefix?
              (begin (display-line (string-append indent-1 (first packet))) (+ 1 indent-level))
              indent-level))
          (if show-suffix?
            (display-line (prefix-tree->indent-tree-string (tail packet) indent-level)))))
      a)))

(define (output-handler-proc arguments) "list list ->"
  (arguments->formats& arguments
    (l (show-file? show-prefix? show-suffix?)
      (l (result)
        (apply
          (l (type . data)
            (if (equal? (q parsed-itpn) type)
              (map-apply
                (l (path . data)
                  (display-parsed-itpn-one path data show-file? show-prefix? show-suffix?))
                data)
              (debug-log result)))
          result)))))

(define (result-handler arguments a process-after output-handler) "list list -> [list]"
  (if (error? a) a
    (if (null? a) (exit 0)
      (case (first a) ((syntax-check) (exit (if (every identity (tail (tail a))) 0 1)))
        ((parsed-itpn) (error-pass-if-not (process-after a) output-handler))))))

(define (itpn-filter-cli)
  (let* ((arguments (command-line-interface)))
    (error-pass-if
      (result-handler arguments
        ( (input-handler-proc arguments) (alist-q-ref arguments file-paths)
          (process-one-proc arguments))
        (process-after-proc arguments) (output-handler-proc arguments))
      display-error-and-exit)))

(itpn-filter-cli)
