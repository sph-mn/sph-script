#!/usr/bin/env ruby

# prepend a video quality and duration score to filenames.
# if option -p was given, prepend "{height}p{fps}." to video filenames.
# call without arguments for more options.
# video quality estimation: https://sph.mn/computer/designs/video-quality-score.html

dry_run = false
quality_score = true
with_duration = true
paths = []

while !ARGV.empty? && ARGV[0].start_with?("-")
  arg = ARGV.shift
  if arg == "-d" then dry_run = true
  elsif arg == "-p" then quality_score = false
  elsif arg == "-t" then with_duration = false
  elsif arg == "-i" then comparison_listing = true
  else
    puts "Unknown option: #{arg}"
    exit 1
  end
end

def ffprobe_properties(path, entries)
  require "open3"
  entries_str = entries.join(",")
  cmd = ["ffprobe", "-v", "quiet", "-select_streams", "v:0",
         "-show_entries", "stream=#{entries_str}", "-of", "default=noprint_wrappers=1", path]
  stdout_str, stderr_str, status = Open3.capture3(*cmd)
  return {} unless status.success?
  data = {}
  stdout_str.lines.each do |line|
    key, value = line.strip.split("=")
    data[key] = value
  end
  data
end

def get_duration_string(duration)
  if duration
    duration = duration.to_f
    if duration < 500 then "d1"
    elsif duration > 5000 then "d4"
    elsif duration > 2500 then "d3"
    else "d2" end
  else "d0" end
end

def parse_frame_rate(r_frame_rate)
  if r_frame_rate
    nums = r_frame_rate.split("/")
    if nums.length == 2
      nums[0].to_f / nums[1].to_f
    else
      r_frame_rate.to_f
    end
  else nil end
end

def get_quality_score video_width, video_height, frame_rate, bit_depth, bit_rate, codec_name
  # v2025-10
  codec_efficiency = {
    "av1" => 1.5,
    "h264" => 1.0,
    "h266" => 2.0,
    "hevc" => 1.7,
    "vp8" => 0.9,
    "vp9" => 1.3
  }
  codec_relative_efficiency = codec_efficiency[codec_name] || 0.8

  bit_depth = [bit_depth.to_f, 6.0].max
  frame_rate = [frame_rate.to_f, 0.1].max
  bit_rate = [bit_rate.to_f, 1.0].max
  pixel_count = [(video_width.to_f * video_height.to_f), 1e-9].max

  base_resolution = 640.0 * 480.0
  base_frame_rate = 30.0
  base_bit_depth = 8.0

  resolution_factor = Math.log2(1.0 + pixel_count / base_resolution)
  frame_rate_factor = Math.log2(1.0 + frame_rate / base_frame_rate)
  bit_depth_factor = Math.log2(bit_depth / base_bit_depth) + 1.0

  bits_per_pixel_per_frame = bit_rate / (pixel_count * frame_rate)
  optimal_bppf = 0.12 * bit_depth / base_bit_depth / codec_relative_efficiency

  sigmoid_slope = 8.0
  bitrate_ratio = bits_per_pixel_per_frame / optimal_bppf
  bitrate_factor = 1.0 / (1.0 + Math.exp(-sigmoid_slope * (bitrate_ratio - 1.0)))

  weight_resolution = 0.25
  weight_frame_rate = 0.15
  weight_bit_depth = 0.10
  weight_bitrate = 0.50

  quality_score = weight_resolution * resolution_factor +
    weight_frame_rate * frame_rate_factor +
    weight_bit_depth * bit_depth_factor +
    weight_bitrate * bitrate_factor

  (quality_score * 10).round.to_i
end

def get_tag(path, with_duration, quality_score)
  entries = ["bits_per_raw_sample", "bit_rate", "codec_name", "duration", "height", "r_frame_rate", "width"]
  props = ffprobe_properties(path, entries)

  def parse_numeric(value, default)
    if value.is_a?(String) && value.match?(/\A[-+]?\d*\.?\d+\Z/)
      value.include?('.') ? value.to_f : value.to_i
    else
      default
    end
  end

  duration_string = ""
  if with_duration
    duration = props["duration"] ? parse_numeric(props["duration"], 0.0) : 0.0
    duration_string = get_duration_string(duration)
  end

  height = props["height"] ? parse_numeric(props["height"], 320) : 320
  width = props["width"] ? parse_numeric(props["width"], 240) : 240

  if quality_score
    bitdepth = props["bits_per_raw_sample"] ? parse_numeric(props["bits_per_raw_sample"], 8) : 8
    bitrate = props["bit_rate"] ? parse_numeric(props["bit_rate"], 1000) : 1000
    framerate = parse_frame_rate(props["r_frame_rate"]) || 15.0
    codec = props["codec_name"]
    if width && height && codec
      quality = get_quality_score width, height, framerate, bitdepth, bitrate, codec
      tag = "q#{quality}#{duration_string}"
    else tag = "q0#{duration_string}" end
  else
    shortest_side = [width, height].min
    framerate = parse_frame_rate(props["r_frame_rate"])
    tag = "#{duration_string}p#{shortest_side}"
    tag += "f#{framerate.round}" if framerate
  end

  tag
end

def add_tag(path, tag, dry_run)
  require "fileutils"

  dirname = File.dirname(path)
  basename = File.basename(path)
  new_basename = "#{tag}.#{basename}"
  new_path = File.join(dirname, new_basename)

  if new_path != path
    if dry_run
      puts "\"#{path}\" -> \"#{new_path}\""
    else
      FileUtils.mv(path, new_path)
    end
  end
end

def print_comparison_listing(sizes: [[320,240],[640,480],[1280,720],[1920,1080],[2560,1440],[3840,2160],[7680,4320]], framerates: [30,60,120], bitdepths: [8,10], bitrates: [15_000_000, 75_000_000, 150_000_000, 300_000_000, 900_000_000], codecs: ["h264","av1"], io: $stdout)
  sizes.each do |w,h|
    puts "~~~"
    codecs.each do |codec|
      framerates.each do |fps|
        bitdepths.each do |bd|
          bitrates.each do |br|
            score = get_quality_score w, h, fps, bd, br, codec
            base = (w * h * fps * bd)
            io.puts "#{w}x#{h} #{fps} #{bd} #{base} #{br} #{codec} -> #{score}"
          end
        end
      end
    end
    puts "~~~"
  end
end

if comparison_listing
  print_comparison_listing()
else
  paths = ARGV

  if paths.empty?
    puts "usage: [options] files ..."
    puts "options"
    puts "  -d  dry-run"
    puts "  -p  use pixel format (e.g. 720p30) instead of quality score"
    puts "  -t  without duration tag"
    puts "  -i  print comparison table"
    exit 1
  end
  paths.each do |path|
    if File.file?(path)
      tag = get_tag path, with_duration, quality_score
      add_tag(path, tag, dry_run) if tag
    end
  end
end
